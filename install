#!/usr/bin/env bash

set -Eeuo pipefail

# Get system info.
OS=$(uname -s)
ARCH=$(uname -m)

# Install options.
PRIME=0
LINK=0
PKGS=0
GITHUB=0

# Logging options.
USE_COLORS=${USE_COLORS:-1}     # 1 = colored output,      0 = plain
ENABLE_DEBUG=${ENABLE_DEBUG:-0} # 1 = show debug messages, 0 = hide
DATE_FORMAT="%Y-%m-%d %H:%M:%S"

# ANSI color codes.
RESET="\e[0m"
RED="\e[31m"
GREEN="\e[32m"
YELLOW="\e[33m"
BLUE="\e[34m"
CYAN="\e[36m"

# Internal logging function.
_log() {
  local level="$1"
  local msg="$2"
  local color="$3"
  local stream=${4:-1}
  local timestamp
  timestamp=$(date +"$DATE_FORMAT")

  if [[ $USE_COLORS -eq 1 && -n "$color" ]]; then
    printf "%s ${color}[%-7s]${RESET} %s\n" "$timestamp" "$level" "$msg" >&"$stream"
  else
    printf "%s [%-7s] %s\n" "$timestamp" "$level" "$msg" >&"$stream"
  fi
}

# Public logging functions.
info() { _log "INFO" "$1" "$BLUE"; }
warn() { _log "WARN" "$1" "$YELLOW" 2; }
error() { _log "ERROR" "$1" "$RED" 2; }
success() { _log "SUCCESS" "$1" "$GREEN"; }
debug() { if [[ $ENABLE_DEBUG -eq 1 ]]; then _log "DEBUG" "$1" "$CYAN" 2; fi; }

show_help() {
  cat <<'EOF'
Bootstrap script.

Without any options provided, this script will check if required tools are
installed and will then clone or pull dotfiles repository to ~/.dotfiles.

Options can be provided to enable extra functionality.

Usage:
  ./install [--prime] [--link] [--pkgs] [--github] [-h | --help]

Options:
  --prime       Ensure system has required packages installed
  --link        Symlink config files
  --pkgs        Install packages
  --github      Authenticate with GitHub on this device

  -h, --help    Print this help message

Environemnt Variables:
  USE_COLORS      Control colored logging.
                  1 = enable; 0 = disable (default: 1)

  ENABLE_DEBUG    Control debug logging.
                  1 = enable; 0 = disable (default: 0)
EOF
  exit 0
}

parse_args() {
  while [[ $# -gt 0 ]]; do
    case $1 in
    --prime) PRIME=1 ;;
    --link) LINK=1 ;;
    --pkgs) PKGS=1 ;;
    --github) GITHUB=1 ;;
    -h | --help) show_help ;;
    esac
    shift
  done
}

flag() {
  [[ $1 -eq 1 ]]
}

prime_system() {

  # The purpose of this script is to prime a system, MacOS or Linux, so it is in
  # a state where the main bootstrapping process can begin.
  #
  # This essentially boils down to making sure a few essential packages are
  # installed:
  # - git
  # - python3
  # - curl/wget
  # - tar/unzip/bzip2/xz
  #
  # For MacOS it is a bit more involved as some of these things are not available
  # OOTB, and there isn't even a builtin package manager.
  #
  # For Linux, it should just be a case of determining which package manager to
  # use and then installing the software.

  prime_macos() {
    case $ARCH in
    *arm*) PREFIX="/opt/homebrew" ;;
    *x86_64*) PREFIX="/usr/local" ;;
    *)
      error "$ARCH CPU architecture is not supported"
      return 1
      ;;
    esac

    info "OS      : $OS"
    info "ARCH    : $ARCH"
    info "PREFIX  : $PREFIX"

    info "Checking if Homebrew is already installed..."

    if ! command -v "$PREFIX/bin/brew" &>/dev/null; then
      warn "Homebrew not installed"
      info "Installing Homebrew. This will also install Xcode Command Line Tools if required..."
      if ! /bin/bash -c \
        "$(curl \
          -fsSL \
          https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"; then
        error "Homebrew installation failed"
        return 1
      fi
    else
      info "Homebrew already installed"
    fi

    info "Adding brew to PATH..."
    if ! command -v brew &>/dev/null; then
      eval "$("$PREFIX/bin/brew" shellenv)"
    fi

    # Default: curl bzip2 tar unzip
    # Xcode Command Line Tools: git python3

    brew update
    # brew upgrade
    brew install \
      wget \
      xz \
      gh

    success "MacOS primed successfully"
  }

  prime_linux() {
    if ! [[ -f /etc/os-release ]]; then
      error "Couldn't determine Linux distro as /etc/os-release does not exist"
      return 1
    fi

    prime_ubuntu_debian() {
      sudo apt-get update -y
      sudo apt-get upgrade -y
      sudo apt-get install -y \
        git python3 \
        curl wget \
        tar unzip bzip2 xz-utils

      # Install latest version of GitHub CLI.
      (type -p wget >/dev/null || (sudo apt update && sudo apt install wget -y)) &&
        sudo mkdir -p -m 755 /etc/apt/keyrings &&
        out=$(mktemp) && wget -nv -O"$out" https://cli.github.com/packages/githubcli-archive-keyring.gpg &&
        cat "$out" | sudo tee /etc/apt/keyrings/githubcli-archive-keyring.gpg >/dev/null &&
        sudo chmod go+r /etc/apt/keyrings/githubcli-archive-keyring.gpg &&
        sudo mkdir -p -m 755 /etc/apt/sources.list.d &&
        echo "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" | sudo tee /etc/apt/sources.list.d/github-cli.list >/dev/null &&
        sudo apt update &&
        sudo apt install gh -y
    }

    prime_fedora() {
      error "TODO: Implement Fedora"
      return 1
    }

    prime_arch() {
      error "TODO: Implement Arch"
      return 1
    }

    prime_alpine() {
      error "TODO: Implement Alpine"
      return 1
    }

    # Load all data about OS into environment variables.
    # This is clean and avoids any weird parsing.
    # shellcheck disable=SC1091 # This file never exists on MacOS and the warning is annoying.
    . /etc/os-release

    # This is mainly for package managers. While it would probably make sense to
    # use ID_LIKE, this is an optional field in the systemd specification.
    # Therefore it is safer to just hardcode distros and use ID instead.
    # See 'https://www.freedesktop.org/software/systemd/man/latest/os-release.html#ID_LIKE='.

    case $ID in
    ubuntu | debian) prime_ubuntu_debian ;;
    fedora) prime_fedora ;;
    arch) prime_arch ;;
    alpine) prime_alpine ;;
    *)
      error "Unsupported distro: $ID"
      return 1
      ;;
    esac

    success "Linux primed successfully"
  }

  case $OS in
  Darwin) prime_macos ;;
  Linux) prime_linux ;;
  esac

  success "System primed successfully"
}

# TODO: Including checking requirements under prime option?

check_requirements() {

  info "Checking required tools are available..."

  ################################################################################
  ### DECLARE REQUIRED TOOLS
  ################################################################################

  # Array to track missing essentials.
  missing=()

  # All of these are required.
  # TODO: Can probably remove python3 since I'm not using Ansible.
  required=(git python3 gh)

  # At least one of these is required.
  downloaders=(curl wget)

  # These are recommended.
  archive_tools=(tar unzip xz bzip2)

  ################################################################################
  ### CHECK TOOLS
  ################################################################################

  ### Essential #############################################################
  # (all required)

  for cmd in "${required[@]}"; do
    if ! command -v "$cmd" &>/dev/null; then
      missing+=("$cmd")
    fi
  done

  ### Downloader ############################################################
  # (require at least one)

  found=0

  for cmd in "${downloaders[@]}"; do
    if command -v "$cmd" &>/dev/null; then
      found=1
      break
    fi
  done

  if [[ $found -eq 0 ]]; then
    missing+=("curl or wget")
  fi

  unset -v found

  ### Archive Tools #########################################################
  # (optional, just warn)

  for cmd in "${archive_tools[@]}"; do
    if ! command -v "$cmd" &>/dev/null; then
      warn "$cmd is not installed"
    fi
  done

  ################################################################################
  ### REPORT RESULTS
  ################################################################################

  # Report missing essentials
  if [[ ${#missing[@]} -ne 0 ]]; then
    error "the following required tools are missing:"
    for cmd in "${missing[@]}"; do
      error "  - $cmd"
    done
    exit 1
  fi

  success "All essential tools are installed"
}

################################################################################
################################################################################
################################################################################
################################################################################
################################################################################

setup_dotfiles_repo() {
  if [[ -d $DOTFILES ]]; then

    info "Dotfiles already exist locally at $DOTFILES"
    info "Pulling latest changes..."

    before=$(git -C "$DOTFILES" rev-parse HEAD)

    if ! git -C "$DOTFILES" pull; then #--rebase?
      error "Pulling latest changes failed"
      return 1
    fi

    success "Dotfiles repo updated successfully"

    after=$(git -C "$DOTFILES" rev-parse HEAD)

    if [[ $before != "$after" ]]; then
      info "Repo updated, re-executing install script..."
      exec "$DOTFILES/install" "$@"
    fi

  else

    local url
    url="https://github.com/peter-bread/.dotfiles.git"

    info "Dotfiles do not exist locally at $DOTFILES"
    info "Cloning $url into $DOTFILES"

    if ! git clone --branch=main "$url" "$DOTFILES"; then
      error "Cloning dotfiles failed"
      return 1
    fi

    success "Dotfiles repo cloned successfully"

  fi

  success "Dotfiles repo setup successfully"
}

link_configs() {
  # Ensure important environment variables are set ($DOTFILES, $ZDOTDIR, $XDG_*).
  source ./zsh/zshenv

  # TODO: Move this logic to its own file or function?
  mkdir -p "$HOME/opt"
  mkdir -p "$HOME/.local/bin"
  mkdir -p "$DEVELOPER"
  mkdir -p "$DEVELOPER/probe"
  mkdir -p "$DEVELOPER/thirdparty"

  dot_link() {
    local module=$1
    local file="$DOTFILES/_link/${module}"

    if [[ -f $file ]]; then
      # echo -e "${BLUE}=> Linking ${YELLOW}${module} ${BLUE}config...${RESET}"
      info "Linking $module config..."
      # shellcheck disable=SC1090 # Doesn't really matter.
      . "$file"
    else
      # echo -e "${RED}=> Error: ${YELLOW}${module} ${RED}config does not exist${RESET}"
      error "$module config does not exist"
      return 1
    fi
  }

  link_from_manifest() {
    local manifest=$1

    info "Attempting to link configs from $manifest"

    if ! [[ -f $manifest ]]; then
      error "$manifest does not exist"
      return 1
    fi

    while IFS= read -r item; do
      [[ -n $item && $item != \#* ]] || continue
      dot_link "$item" || return
    done <"$manifest"

    success "Linked configs from $manifest"
  }

  link_from_manifest MANIFEST.common || return

  case $OS in
  Darwin) link_from_manifest MANIFEST.macos || return ;;
  Linux) link_from_manifest MANIFEST.linux || return ;;
  esac

  success "Configs linked successfully"
}

install_pkgs() {
  case $OS in
  Darwin)
    cat ./packages/brew/Brewfile | head -n15
    error "TODO: Install packages on MacOS"
    return 1
    ;;
  Linux)
    error "TODO: Install packages on Linux"
    return 1
    ;;
  esac

  success "Packages installed successfully"
}

setup_personal_github() {
  local account="peter-bread"
  local category="personal"

  ./scripts/setup-github-account "$account" \
    --category "$category" \
    --dir "${DEVELOPER:-$HOME/Developer}"
}

main() {
  parse_args "$@" || exit

  if flag "$PRIME"; then
    prime_system || exit
  fi

  check_requirements || exit

  DOTFILES=${DOTFILES:-$HOME/.dotfiles}

  setup_dotfiles_repo "$@" || exit

  cd "$DOTFILES" || exit

  if flag "$LINK"; then
    link_configs || exit
  fi

  if flag "$PKGS"; then
    # TODO: Install packages.
    install_pkgs || exit
  fi

  if flag "$GITHUB"; then
    setup_personal_github || exit
  fi

  success "$0 ${*:+${*} }completed successfully"
}

main "$@"
