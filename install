#!/usr/bin/env bash

set -Eeuo pipefail

DOTFILES="$HOME/.dotfiles"

# Get system info.
OS=$(uname -s)
ARCH=$(uname -m)

# POSITIONAL ARGUMENTS
EXPECTED_ARGS=0
ARGS=()

# OPTIONS
: "${PRIME:=0}"
: "${MODULES:=0}"
: "${PKGS:=0}"
: "${GITHUB:=0}"

# OPTION ARGUMENTS
: "${NVIM:=}"

# Logging options.
: "${ENABLE_COLOR:=1}" # 1 = colored output,      0 = plain
: "${ENABLE_DEBUG:=0}" # 1 = show debug messages, 0 = hide
DATE_FORMAT="%Y-%m-%d %H:%M:%S"

# Developer Options
: "${DEV_USE_LOCAL:=0}"

# ANSI color codes.
RESET="\e[0m"
RED="\e[31m"
GREEN="\e[32m"
YELLOW="\e[33m"
BLUE="\e[34m"
CYAN="\e[36m"

# Internal logging function.
_log() {
  local level="$1"
  local msg="$2"
  local color="$3"
  local stream=${4:-1}
  local timestamp
  timestamp=$(date +"$DATE_FORMAT")

  if [[ $ENABLE_COLOR -eq 1 && -n "$color" ]]; then
    printf "%s ${color}[%-7s]${RESET} %s\n" "$timestamp" "$level" "$msg" >&"$stream"
  else
    printf "%s [%-7s] %s\n" "$timestamp" "$level" "$msg" >&"$stream"
  fi
}

# Public logging functions.
info() { _log "INFO" "$1" "$BLUE"; }
warn() { _log "WARN" "$1" "$YELLOW" 2; }
error() { _log "ERROR" "$1" "$RED" 2; }
success() { _log "SUCCESS" "$1" "$GREEN"; }
debug() { if [[ $ENABLE_DEBUG -eq 1 ]]; then _log "DEBUG" "$1" "$CYAN" 2; fi; }

available() {
  [[ -n "$1" ]] && command -v -- "$1" &>/dev/null
}

unavailable() {
  ! available "$1"
}

show_help() {
  cat <<'EOF'
Bootstrap script.

Without any options provided, this script will check if required tools are
installed and will then clone or pull dotfiles repository to ~/.dotfiles.

Options can be provided to enable extra functionality.

Usage:
  ./install [--prime] [--modules] [--pkgs] [--github] [--nvim <repo_name>] [-h | --help]

Options:
  --prime       Ensure system has required packages installed
  --modules     Install modules from MANIFEST.* files
  --pkgs        Install packages
  --github      Authenticate with GitHub on this device
  --nvim        Clone Neovim config as specified by <repo_name>

                The <repo_name> argument can be one of:
                  - A short name (e.g. "peter.nvim"), resolved as:
                      https://github.com/peter-bread/<repo_name>.git
                  - A full "owner/repo" pair (e.g. "someone/other.nvim"), resolved as:
                      https://github.com/<owner>/<repo_name>.git
                  - A full Git URL (e.g. "https://github.com/user/repo.git"), HTTPS or SSH, used as-is

  -h, --help    Print this help message

Environment Variables:
  These variables mirror the options above. Flags provided on the command line
  take precedence over environment variables. All boolean variables default to 0
  (disabled) unless otherwise noted.

  Option Flags (0 = disable, 1 = enable):
    PRIME       Enable system bootstrap to ensure required packages are installed
    MODULES     Install modules from MANIFEST.* files
    PKGS        Install packages
    GITHUB      Authenticate with GitHub on this device

  Option Arguments (string; default = empty):
    NVIM        Neovim configuration repository to clone.

  Logging and Output:
    ENABLE_COLOR  Enable colored logging output (default: 1)
    ENABLE_DEBUG  Enable debug logging (default: 0)

  Developer / Advanced:
    DEV_USE_LOCAL   Developer mode: do not attempt to clone/pull dotfiles repo.
                    Useful when testing WIP scripts in a Docker container.
EOF
  exit 0
}

parse_args() {

  require_arg() {
    local name="$1"
    local token="$2"
    local next="${3-}"
    local value=""

    # Handle --flag=value form.
    if [[ $token == *=* ]]; then
      value="${token#*=}"
    else
      # Handle --flag value form.
      value="$next"
    fi

    if [[ -z $value ]]; then
      error "$name requires a non-empty value"
      return 1
    fi

    echo "$value"
  }
  while [[ $# -gt 0 ]]; do
    case $1 in
    --prime) PRIME=1 ;;
    --modules) MODULES=1 ;;
    --pkgs) PKGS=1 ;;
    --github) GITHUB=1 ;;
    --nvim | --nvim=*)
      NVIM=$(require_arg --nvim "$1" "${2-}") || return
      [[ $1 != *=* ]] && shift # Only shift extra if not --flag=value form.
      ;;
    -h | --help) show_help ;;
    -*)
      error "Unexpected option: $1"
      return 1
      ;;
    *) ARGS+=("$1") ;;
    esac
    shift
  done

  if [[ ${#ARGS[@]} -lt $EXPECTED_ARGS ]]; then
    error "Expected $((EXPECTED_ARGS - ${#ARGS[@]})) more argument(s)"
    return 1
  fi

  if [[ ${#ARGS[@]} -gt $EXPECTED_ARGS ]]; then
    error "Unexpected extra positional arguments: ${ARGS[*]:$((EXPECTED_ARGS))}"
    return 1
  fi

}

flag() {
  [[ $1 -eq 1 ]]
}

flag_arg() {
  [[ -n $1 ]]
}

prime_system() {

  # The purpose of this script is to prime a system, MacOS or Linux, so it is in
  # a state where the main bootstrapping process can begin.
  #
  # This essentially boils down to making sure a few essential packages are
  # installed:
  # - git
  # - python3
  # - curl/wget
  # - tar/unzip/bzip2/xz
  #
  # For MacOS it is a bit more involved as some of these things are not available
  # OOTB, and there isn't even a builtin package manager.
  #
  # For Linux, it should just be a case of determining which package manager to
  # use and then installing the software.

  prime_macos() {
    case $ARCH in
    *arm*) PREFIX="/opt/homebrew" ;;
    *x86_64*) PREFIX="/usr/local" ;;
    *)
      error "$ARCH CPU architecture is not supported"
      return 1
      ;;
    esac

    info "OS      : $OS"
    info "ARCH    : $ARCH"
    info "PREFIX  : $PREFIX"

    info "Checking if Homebrew is already installed..."

    if unavailable "$PREFIX/bin/brew"; then
      warn "Homebrew not installed"
      info "Installing Homebrew. This will also install Xcode Command Line Tools if required..."
      if ! /bin/bash -c \
        "$(curl \
          -fsSL \
          https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"; then
        error "Homebrew installation failed"
        return 1
      fi
    else
      info "Homebrew already installed"
    fi

    info "Adding brew to PATH..."
    if unavailable brew; then
      eval "$("$PREFIX/bin/brew" shellenv)"
    fi

    # Default: curl bzip2 tar unzip
    # Xcode Command Line Tools: git python3

    brew update
    # brew upgrade
    brew install \
      wget \
      xz \
      gh

    success "MacOS primed successfully"
  }

  prime_linux() {
    if ! [[ -f /etc/os-release ]]; then
      error "Couldn't determine Linux distro as /etc/os-release does not exist"
      return 1
    fi

    prime_ubuntu_debian() {
      sudo apt-get update -y
      sudo apt-get upgrade -y
      sudo apt-get install -y \
        git python3 \
        curl wget \
        tar unzip bzip2 xz-utils

      # Install latest version of GitHub CLI.
      (type -p wget >/dev/null || (sudo apt update && sudo apt install wget -y)) &&
        sudo mkdir -p -m 755 /etc/apt/keyrings &&
        out=$(mktemp) && wget -nv -O"$out" https://cli.github.com/packages/githubcli-archive-keyring.gpg &&
        cat "$out" | sudo tee /etc/apt/keyrings/githubcli-archive-keyring.gpg >/dev/null &&
        sudo chmod go+r /etc/apt/keyrings/githubcli-archive-keyring.gpg &&
        sudo mkdir -p -m 755 /etc/apt/sources.list.d &&
        echo "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" | sudo tee /etc/apt/sources.list.d/github-cli.list >/dev/null &&
        sudo apt update &&
        sudo apt install gh -y
    }

    prime_fedora() {
      error "TODO: Implement Fedora"
      return 1
    }

    prime_arch() {
      error "TODO: Implement Arch"
      return 1
    }

    prime_alpine() {
      error "TODO: Implement Alpine"
      return 1
    }

    # Load all data about OS into environment variables.
    # This is clean and avoids any weird parsing.
    # shellcheck disable=SC1091 # This file never exists on MacOS and the warning is annoying.
    . /etc/os-release

    # This is mainly for package managers. While it would probably make sense to
    # use ID_LIKE, this is an optional field in the systemd specification.
    # Therefore it is safer to just hardcode distros and use ID instead.
    # See 'https://www.freedesktop.org/software/systemd/man/latest/os-release.html#ID_LIKE='.

    case $ID in
    ubuntu | debian) prime_ubuntu_debian ;;
    fedora) prime_fedora ;;
    arch) prime_arch ;;
    alpine) prime_alpine ;;
    *)
      error "Unsupported distro: $ID"
      return 1
      ;;
    esac

    success "Linux primed successfully"
  }

  case $OS in
  Darwin) prime_macos ;;
  Linux) prime_linux ;;
  esac

  success "System primed successfully"
}

# TODO: Including checking requirements under prime option?

check_requirements() {

  info "Checking required tools are available..."

  ################################################################################
  ### DECLARE REQUIRED TOOLS
  ################################################################################

  # Array to track missing essentials.
  missing=()

  # All of these are required.
  # TODO: Can probably remove python3 since I'm not using Ansible.
  required=(git python3 gh)

  # At least one of these is required.
  downloaders=(curl wget)

  # These are recommended.
  archive_tools=(tar unzip xz bzip2)

  ################################################################################
  ### CHECK TOOLS
  ################################################################################

  ### Essential #############################################################
  # (all required)

  for cmd in "${required[@]}"; do
    if unavailable "$cmd"; then
      missing+=("$cmd")
    fi
  done

  ### Downloader ############################################################
  # (require at least one)

  found=0

  for cmd in "${downloaders[@]}"; do
    if available "$cmd"; then
      found=1
      break
    fi
  done

  if [[ $found -eq 0 ]]; then
    missing+=("curl or wget")
  fi

  unset -v found

  ### Archive Tools #########################################################
  # (optional, just warn)

  for cmd in "${archive_tools[@]}"; do
    if unavailable "$cmd"; then
      warn "$cmd is not installed"
    fi
  done

  ################################################################################
  ### REPORT RESULTS
  ################################################################################

  # Report missing essentials
  if [[ ${#missing[@]} -ne 0 ]]; then
    error "the following required tools are missing:"
    for cmd in "${missing[@]}"; do
      error "  - $cmd"
    done
    exit 1
  fi

  success "All essential tools are installed"
}

################################################################################
################################################################################
################################################################################
################################################################################
################################################################################

setup_dotfiles_repo() {
  if [[ -d $DOTFILES ]]; then

    info "Dotfiles already exist locally at $DOTFILES"
    info "Pulling latest changes..."

    before=$(git -C "$DOTFILES" rev-parse HEAD)

    if ! git -C "$DOTFILES" pull; then #--rebase?
      error "Pulling latest changes failed"
      return 1
    fi

    success "Dotfiles repo updated successfully"

    after=$(git -C "$DOTFILES" rev-parse HEAD)

    if [[ $before != "$after" ]]; then
      info "Repo updated, re-executing install script..."
      exec "$DOTFILES/install" "$@"
    fi

  else

    local url="https://github.com/peter-bread/.dotfiles.git"

    info "Dotfiles do not exist locally at $DOTFILES"
    info "Cloning $url into $DOTFILES"

    if ! git clone --branch=main "$url" "$DOTFILES"; then
      error "Cloning dotfiles failed"
      return 1
    fi

    success "Dotfiles repo cloned successfully"

  fi

  success "Dotfiles repo setup successfully"
}

install_modules() {

  dot_install() {
    local module=$1

    local module_dir="$DOTFILES/${module}"
    local module_install="$module_dir/install"

    if [[ ! -d $module_dir ]]; then
      error "$module module does not exist"
      return 1
    fi

    # If the module exists but has no install script, it is likely a
    # "special" module. In this case, documentation should be consulted.
    if [[ ! -f $module_install ]]; then
      warn "$module module does not contain an install script. Skipping..."
      return
    fi

    if [[ ! -x $module_install ]]; then
      warn "$module module contains a non-executable install script. Skipping..."
      return
    fi

    info "Installing $module module..."

    if "$module_install"; then
      success "Installed $module module successfully"
    else
      error "Failed to install $module module"
      return 1
    fi

  }

  install_from_manifest() {
    local manifest=$1

    info "Attempting to install modules from $manifest"

    if ! [[ -f $manifest ]]; then
      error "$manifest does not exist"
      return 1
    fi

    while IFS= read -r item; do
      [[ -n $item && $item != \#* ]] || continue
      dot_install "$item" || return
    done <"$manifest"

    success "Installed modules from $manifest"
  }

  install_from_manifest ./MANIFEST.common || return

  case $OS in
  Darwin) install_from_manifest ./MANIFEST.macos || return ;;
  Linux) install_from_manifest ./MANIFEST.linux || return ;;
  # TODO: Use /etc/os-release for distro-specific manifests?
  esac

  success "Modules installed successfully"
}

install_pkgs() {
  case $OS in
  Darwin)
    error 'Command to run: brew bundle --file=./packages/brew/Brewfile --verbose'
    error "TODO: Install packages on MacOS"
    return 1
    ;;
  Linux)
    export PREFIX="$HOME/.local"
    VERSION="stable" ./packages/manual/neovim
    unset PREFIX

    error "TODO: Install packages on Linux"
    return 1
    ;;
  esac

  success "Packages installed successfully"
}

setup_personal_github() {
  local account="peter-bread"
  local category="personal"

  # TODO: Add logging.

  # --github-auth (and --add-keys, but this is because it depends on the other flag)
  # requires manual intervention to copy and paste codes into a browser. This means
  # it cannot be used in a headless environment.

  ./bin/setup-github-account "$account" \
    --category "$category" \
    --base-dir "${DEVELOPER:-$HOME/Developer}" \
    --email "145384599+peter-bread@users.noreply.github.com" \
    --allowed-signers \
    --gen-keys \
    --github-auth \
    --add-keys
}

setup_neovim() {

  info "Downloading Neovim config..."

  is_full_url() {
    local input="$1"
    [[ "$input" =~ ^(https://|git@) ]]
  }

  local input="$NVIM"
  local url

  if is_full_url "$input"; then
    url="$input"
  elif [[ "$input" == */* ]]; then
    url="https://github.com/$input"
  else
    url="https://github.com/peter-bread/$input"
  fi

  if [[ $url != *.git ]]; then
    url="${url}.git"
  fi

  info "Resolved Neovim Git repository URL: $url"

  repo="${url##*/}"
  repo="${repo%.git}"

  info "Resolved Neovim Git repository name: $repo"

  dir="${XDG_CONFIG_HOME:-$HOME/.config}/$repo"

  info "Resolved Neovim install location: $dir"

  if [[ -d $dir ]]; then

    info "$dir already exists"
    info "Pulling latest changes..."

    if ! git -C "$dir" pull; then
      error "Pulling latest changes failed"
      return 1
    fi

    success "Neovim config updated successfully"

  else

    info "$dir does not exist"
    info "Cloning $url into $dir"

    if ! git clone --branch=main "$url" "$dir"; then
      error "Cloning neovim config failed"
      return 1
    fi

    success "Neovim config ($repo) cloned successfully"

  fi

  if available nvim; then
    info "Attempting Neovim headless setup..."
    if [[ -x $dir/scripts/install ]]; then
      if "$dir/scripts/install"; then
        success "Neovim headless setup successful"
      else
        error "Neovim headless setup failed"
        return 1
      fi
    else
      warn "Neovim headless installation script could not be found"
    fi
  else
    warn "Neovim not installed"
    warn "Skipping headless setup"
  fi

}

main() {
  parse_args "$@" || return

  if flag "$PRIME"; then
    prime_system || return
  fi

  check_requirements || return

  # Skip pulling changes if testing local development version.
  if flag "$DEV_USE_LOCAL"; then
    warn "DEV_USE_LOCAL is a Developer-only option"
    warn "Skipping dotfiles repo setup"
    warn "Assuming local dotfiles repo exists"
  else
    setup_dotfiles_repo "$@" || return
  fi

  cd "$DOTFILES" || return

  # Export shell-agnostic, non-interactive environment variables.
  source ./env/non-interactive

  if flag "$MODULES"; then
    install_modules || return
  fi

  if flag "$PKGS"; then
    # TODO: Install packages.
    install_pkgs || return
  fi

  if flag "$GITHUB"; then
    setup_personal_github || return
  fi

  if flag_arg "$NVIM"; then
    setup_neovim || return
  fi

  success "$0 ${*:+${*} }completed successfully"
}

main "$@" || exit
